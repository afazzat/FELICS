"Cipher","Block Size (bits)","Key Size (bits)","Implementation Version","Implementation Info","Implementation Authors"
"AES","128","128","01"," AES_128_128 small footprint, 8-bit"," Dmitry Khovratovich "
"AES","128","128","02"," Fast table-based AES implementation"," Dmitry Khovratovich"
"AES","128","128","03"," AES_128_128 small footprint, 8-bit; without memcpy"," Dmitry Khovratovich"
"AES","128","128","04"," AES_128_128 small footprint, 8-bit; store constants in RAM"," Dmitry Khovratovich"
"AES","128","128","05"," AES_128_128 small footprint, 8-bit; without memcpy; store constants in RAM"," Dmitry Khovratovich"
"AES","128","128","06"," Fast table-based AES implementation; store Sbox and inverse Sbox in RAM, the rest of constants (Rcon, T0, T1, T2, T3, inverse T0, inverse T1, inverse T2, inverse T3, inverce MC0, inverse MC1, inverse MC2 and inverse MC3) are stored in ROM because there is not enough RAM for them"," Dmitry Khovratovich"
"AES","128","128","07"," AES_128_128 Assembler version for AVR, MSP, ARM; optimized for speed based on AES_128_128_01 "," André Stemper"
"AES","128","128","08"," AVRAES RijndaelFast"," B. Poettering point-at-infinity.org/avraes/"
"Chaskey","128","128","01"," Cipher reference implementation"," Nicky Mouha"
"Chaskey","128","128","02"," Cipher reference implementation with new rotation functions"," Nicky Mouha, Jason Smith"
"Chaskey","128","128","03"," Assembler implementation"," Nicky Mouha, Virat Shejwalkar, Daniel Dinu"
"Chaskey","128","128","04"," Assembler implementation; unroll 2 rounds"," Nicky Mouha, Virat Shejwalkar, Daniel Dinu"
"Chaskey","128","128","05"," Assembler implementation; unroll 4 rounds"," Nicky Mouha, Virat Shejwalkar, Daniel Dinu"
"Chaskey","128","128","06"," Assembler implementation; fully unroll"," Nicky Mouha, Virat Shejwalkar, Daniel Dinu"
"Chaskey-LTS","128","128","01"," Cipher reference implementation"," Nicky Mouha"
"Chaskey-LTS","128","128","02"," Cipher reference implementation with new rotation functions"," Nicky Mouha, Jason Smith"
"Chaskey-LTS","128","128","03"," Assembler implementation"," Nicky Mouha, Virat Shejwalkar, Daniel Dinu"
"Chaskey-LTS","128","128","04"," Assembler implementation; unroll 2 rounds"," Nicky Mouha, Virat Shejwalkar, Daniel Dinu"
"Chaskey-LTS","128","128","05"," Assembler implementation; unroll 4 rounds"," Nicky Mouha, Virat Shejwalkar, Daniel Dinu"
"Chaskey-LTS","128","128","06"," Assembler implementation; unroll 8 rounds for AVR and ARM; unroll 4 round for MSP"," Nicky Mouha, Virat Shejwalkar, Daniel Dinu"
"Chaskey-LTS","128","128","07"," Assembler implementation; fully unroll"," Nicky Mouha, Virat Shejwalkar, Daniel Dinu"
"Fantomas","128","128","01"," reference implementation"," Johann Großschädl"
"Fantomas","128","128","02"," reference implementation; store L-Boxes and inverse L-Boxes in RAM"," Johann Großschädl"
"HIGHT","64","128","01"," reference implementation; delta constants are computed when encryption key schedule is called"," Daniel Dinu"
"HIGHT","64","128","02"," reference implementation; delta constants are precomputed"," Daniel Dinu"
"HIGHT","64","128","03"," cleaner reference implementation; delta constants are computed when encryption key schedule is called"," Daniel Dinu"
"HIGHT","64","128","04"," cleaner reference implementation; delta constants are precomputed"," Daniel Dinu"
"HIGHT","64","128","05"," fully unrolled implementation; delta constants are precomputed"," Daniel Dinu"
"HIGHT","64","128","06"," fully unrolled implementation; delta constants are precomputed; auxiliary functions (F0 and F1) are inlined; round keys are computed in a different order"," Daniel Dinu"
"HIGHT","64","128","07"," reference implementation; delta constants are precomputed; store constants in RAM"," Daniel Dinu"
"HIGHT","64","128","08"," cleaner reference implementation; delta constants are precomputed; store constants in RAM"," Daniel Dinu"
"HIGHT","64","128","09"," fully unrolled implementation; delta constants are precomputed; store constants in RAM"," Daniel Dinu"
"HIGHT","64","128","10"," fully unrolled implementation; delta constants are precomputed; auxiliary functions (F0 and F1) are inlined; round keys are computed in a different order; store constants in RAM"," Daniel Dinu"
"HIGHT","64","128","11"," reference implementation; delta constants are computed when encryption key schedule is called; different implementation for rotations"," Daniel Dinu"
"HIGHT","64","128","12"," reference implementation; delta constants are precomputed; different implementation for rotations"," Daniel Dinu"
"HIGHT","64","128","13"," cleaner reference implementation; delta constants are computed when encryption key schedule is called; different implementation for rotations"," Daniel Dinu"
"HIGHT","64","128","14"," cleaner reference implementation; delta constants are precomputed; different implementation for rotations"," Daniel Dinu"
"HIGHT","64","128","15"," fully unrolled implementation; delta constants are precomputed; different implementation for rotations"," Daniel Dinu"
"HIGHT","64","128","16"," fully unrolled implementation; delta constants are precomputed; auxiliary functions (F0 and F1) are inlined; round keys are computed in a different order; ; different implementation for rotations"," Daniel Dinu"
"HIGHT","64","128","17"," reference implementation; delta constants are precomputed; store constants in RAM; different implementation for rotations"," Daniel Dinu"
"HIGHT","64","128","18"," cleaner reference implementation; delta constants are precomputed; store constants in RAM; different implementation for rotations"," Daniel Dinu"
"HIGHT","64","128","19"," fully unrolled implementation; delta constants are precomputed; store constants in RAM; different implementation for rotations"," Daniel Dinu"
"HIGHT","64","128","20"," fully unrolled implementation; delta constants are precomputed; auxiliary functions (F0 and F1) are inlined; round keys are computed in a different order; store constants in RAM; different implementation for rotations"," Daniel Dinu"
"HIGHT","64","128","21"," Assembly implementation"," Ilwoong Jeong"
"IdentityCipher","128","128","01"," IdentityCipher implementation"," Daniel Dinu"
"IdentityCipher","64","128","01"," IdentityCipher implementation"," Daniel Dinu"
"IdentityCipher","64","80","01"," IdentityCipher implementation"," Daniel Dinu"
"IdentityCipher","64","96","01"," IdentityCipher implementation"," Daniel Dinu"
"LBlock","64","80","01"," reference implementation"," Daniel Dinu"
"LBlock","64","80","02"," cleaner reference implementation"," Daniel Dinu"
"LBlock","64","80","03"," use swap (Swap) function in encryption and decryption"," Daniel Dinu"
"LBlock","64","80","04"," use swap function (not shared) in encryption (SwapEncrypt) and decryption (SwapDecrypt)"," Daniel Dinu"
"LBlock","64","80","05"," use round function (F) in encryption and decryption"," Daniel Dinu"
"LBlock","64","80","06"," use sawp (Swap) function and round function (F) in encryption and decryption"," Daniel Dinu"
"LBlock","64","80","07"," reference implementation using 16 bits operations when possible"," Daniel Dinu"
"LBlock","64","80","08"," reference implementation using 32 bits operations when possible"," Daniel Dinu"
"LBlock","64","80","09"," fully unrolled reference implementation"," Daniel Dinu"
"LBlock","64","80","10"," fully unrolled, swap optimized, reference implementation; precomputed shifted constants for encryption key schedule XOR"," Daniel Dinu"
"LBlock","64","80","11"," fully unrolled, swap optimized, reference implementation using 16 bits operations when possible; precomputed shifted constants for encryption key schedule XOR"," Daniel Dinu"
"LBlock","64","80","12"," fully unrolled, swap optimized, reference implementation using 32 bits operations when possible; precomputed shifted constants for encryption key schedule XOR"," Daniel Dinu"
"LBlock","64","80","13"," reference implementation; store constants in RAM"," Daniel Dinu"
"LBlock","64","80","14"," cleaner reference implementation; store constants in RAM"," Daniel Dinu"
"LBlock","64","80","15"," use swap (Swap) function in encryption and decryption; store constants in RAM"," Daniel Dinu"
"LBlock","64","80","16"," use swap function (not shared) in encryption (SwapEncrypt) and decryption (SwapDecrypt); store constants in RAM"," Daniel Dinu"
"LBlock","64","80","17"," use round function (F) in encryption and decryption; store constants in RAM"," Daniel Dinu"
"LBlock","64","80","18"," use sawp (Swap) function and round function (F) in encryption and decryption; store constants in RAM"," Daniel Dinu"
"LBlock","64","80","19"," reference implementation using 16 bits operations when possible; store constants in RAM"," Daniel Dinu"
"LBlock","64","80","20"," reference implementation using 32 bits operations when possible; store constants in RAM"," Daniel Dinu"
"LBlock","64","80","21"," fully unrolled reference implementation; store constants in RAM"," Daniel Dinu"
"LBlock","64","80","22"," fully unrolled, swap optimized, reference implementation; precomputed shifted constants for encryption key schedule XOR; store constants in RAM"," Daniel Dinu"
"LBlock","64","80","23"," fully unrolled, swap optimized, reference implementation using 16 bits operations when possible; precomputed shifted constants for encryption key schedule XOR; store constants in RAM"," Daniel Dinu"
"LBlock","64","80","24"," fully unrolled, swap optimized, reference implementation using 32 bits operations when possible; precomputed shifted constants for encryption key schedule XOR; store constants in RAM"," Daniel Dinu"
"LEA","128","128","01"," Assembly implementation for AVR and ARM; optimized for speed"," Dongsoo Lee and Ilwoong Jeong"
"LEA","128","128","02"," Assembly implementation for AVR and ARM; optimized for speed-size tradeoff"," Dongsoo Lee and Ilwoong Jeong"
"LEA","128","128","03"," Assembly implementation for AVR and ARM; optimized for size"," Dongsoo Lee and Ilwoong Jeong"
"LEA","128","128","04"," Assembly implementation for MSP; optimized for speed"," Youngjoo Shin"
"LEA","128","128","05"," Assembly implementation for MSP; optimized for speed-size tradeoff"," Youngjoo Shin"
"LEA","128","128","06"," Assembly implementation for MSP; optimized for size"," Youngjoo Shin"
"LEA","128","128","07"," C implementation; fully unrolled reference implementation"," Ilwoong Jeong"
"LEA","128","128","08"," C implementation; partially unrolled reference implementation"," Ilwoong Jeong"
"LEA","128","128","09"," C reference implementation"," Ilwoong Jeong"
"LEA","128","128","10"," Reference implementation; load a block into an array of integers"," Ilwoong Jeong"
"LEA","128","128","11"," C implementation; revised version of v07 (using rot32.h in FELICS framework)"," Ilwoong Jeong"
"LEA","128","128","12"," C implementation; revised version of v08 (using rot32.h in FELICS framework)"," Ilwoong Jeong"
"LEA","128","128","13"," C implementation; revised version of v09 (using rot32.h in FELICS framework)"," Ilwoong Jeong"
"LEA","128","128","14"," Balanced implementation"," Ilwoong Jeong"
"LED","64","80","01"," Cipher reference implementation"," Johann Großschädl"
"LED","64","80","02"," Cipher reference implementation; store constants in RAM"," Johann Großschädl"
"LED","64","80","03"," reference implementation using lookup tables"," Johann Großschädl"
"LED","64","80","04"," reference implementation using lookup tables stored in RAM"," Johann Großschädl"
"Lilliput","64","80","01"," Lilliput v1, easy C implementation"," Julien Francq and Jean-Baptiste Serrou-Soares"
"Lilliput","64","80","02"," Lilliput v1 with embedded C best practices"," Julien Francq and Jean-Baptiste Serrou-Soares"
"Lilliput","64","80","03"," Lilliput v1 with embedded c best practices, T-boxes, clustering by bit8 and strict implementation of Lilliput specifications"," Julien Francq and Jean-Baptiste Serrou Soares"
"Lilliput","64","80","04"," Lilliput v1 -	Key Schedule with strict implementation of Lilliput specifications clustering operations on 4 bits + Encryption/Decryption with easy implementation in C with C language best practices"," Julien Francq and Jean-Baptiste Serrou Soares"
"Lilliput","64","80","05"," Lilliput v1 -	Strict implementation of Lilliput specifications with precomputed operations in arrays for key schedule except of MSP and clustering operations on 4 bits"," Julien Francq and Jean-Baptiste Serrou Soares"
"Lilliput","64","80","06"," Lilliput v1 with 32-bit operations"," Julien Francq and Jean-Baptiste Serrou Soares"
"Lilliput","64","80","07"," Lilliput v1 -	ASM on the entire embedded platforms, with memory optimization (ROM and RAM). The ARM version presents a serial implementation for the encryption / decryption functions."," Julien Francq, Jean-Baptiste Serrou-Soares and Antoine Martinache"
"Piccolo","64","80","01"," Piccolo-64-80, speed-optimized"," Yann Le Corre"
"PRESENT","64","80","01"," Speed-optimized implementation of Present with 80-bit key, 32-bit oriented"," Dmitry Khovratovich"
"PRESENT","64","80","02"," Speed-optimized implementation of Present with 80-bit key, 32-bit oriented"," Dmitry Khovratovich"
"PRESENT","64","80","03"," Speed-optimized implementation of Present with 80-bit key, 32-bit oriented; store constants in RAM"," Dmitry Khovratovich"
"PRESENT","64","80","04"," Speed-optimized implementation of Present with 80-bit key, 32-bit oriented; store Sbox, inverse Sbox and SPboxes in RAM (there is not enough space for IPboxes)"," Dmitry Khovratovich"
"PRESENT","64","80","05"," Speed-optimized implementation of Present with 80-bit key, 32-bit oriented"," Dmitry Khovratovich"
"PRESENT","64","80","06"," Assembly implementation of Present with 80-bit key, 32-bit oriented"," Yann Le Corre"
"PRIDE","64","128","01"," Reference C implementation, no key schedule"," Adnan Baysal"
"PRIDE","64","128","02"," Reference C implementation with key schedule"," Adnan Baysal"
"PRIDE","64","128","03"," Implementation with no extra function call, no key schedule"," Adnan Baysal"
"PRIDE","64","128","04"," Implementation with no extra function call, using key schedule"," Adnan Baysal"
"PRIDE","64","128","05"," Reference C implementation, no key schedule"," Adnan Baysal, Daniel Dinu"
"PRIDE","64","128","06"," Reference C implementation with key schedule"," Adnan Baysal, Daniel Dinu"
"PRIDE","64","128","07"," Implementation with no extra function call, no key schedule"," Adnan Baysal, Daniel Dinu"
"PRIDE","64","128","08"," Implementation with no extra function call, using key schedule"," Adnan Baysal, Daniel Dinu"
"PRINCE","64","128","01"," reference implementation"," Daniel Dinu"
"PRINCE","64","128","02"," use 16 bits operations where possible"," Daniel Dinu"
"PRINCE","64","128","03"," use 32 bits operations where possible"," Daniel Dinu"
"PRINCE","64","128","04"," use 64 bits operations for encryption key schedule; use 32 bits operations where possible"," Daniel Dinu"
"PRINCE","64","128","05"," partially unrolled reference implementation"," Daniel Dinu"
"PRINCE","64","128","06"," partially unrolled reference implementation; use 16 bits operations where possible"," Daniel Dinu"
"PRINCE","64","128","07"," partially unrolled reference implementation; use 32 bits operations where possible"," Daniel Dinu"
"PRINCE","64","128","08"," partially unrolled reference implementation; use 64 bits operations for encryption key schedule; use 32 bits operations where possible"," Daniel Dinu"
"PRINCE","64","128","09"," fully unrolled reference implementation"," Daniel Dinu"
"PRINCE","64","128","10"," fully unrolled reference implementation; use 16 bits operations where possible"," Daniel Dinu"
"PRINCE","64","128","11"," fully unrolled reference implementation; use 32 bits operations where possible"," Daniel Dinu"
"PRINCE","64","128","12"," fully unrolled reference implementation; use 64 bits operations for encryption key schedule; use 32 bits operations where possible"," Daniel Dinu"
"PRINCE","64","128","13"," reference implementation; store constants in RAM"," Daniel Dinu"
"PRINCE","64","128","14"," use 16 bits operations where possible; store constants in RAM"," Daniel Dinu"
"PRINCE","64","128","15"," use 32 bits operations where possible; store constants in RAM"," Daniel Dinu"
"PRINCE","64","128","16"," use 64 bits operations for encryption key schedule; use 32 bits operations where possible; store constants in RAM"," Daniel Dinu"
"PRINCE","64","128","17"," partially unrolled reference implementation; store constants in RAM"," Daniel Dinu"
"PRINCE","64","128","18"," partially unrolled reference implementation; use 16 bits operations where possible; store constants in RAM"," Daniel Dinu"
"PRINCE","64","128","19"," partially unrolled reference implementation; use 32 bits operations where possible; store constants in RAM"," Daniel Dinu"
"PRINCE","64","128","20"," partially unrolled reference implementation; use 64 bits operations for encryption key schedule; use 32 bits operations where possible; store constants in RAM"," Daniel Dinu"
"PRINCE","64","128","21"," fully unrolled reference implementation; store constants in RAM"," Daniel Dinu"
"PRINCE","64","128","22"," fully unrolled reference implementation; use 16 bits operations where possible; store constants in RAM"," Daniel Dinu"
"PRINCE","64","128","23"," fully unrolled reference implementation; use 32 bits operations where possible; store constants in RAM"," Daniel Dinu"
"PRINCE","64","128","24"," fully unrolled reference implementation; use 64 bits operations for encryption key schedule; use 32 bits operations where possible; store constants in RAM"," Daniel Dinu"
"RC5-20","64","128","01"," reference implementation"," Daniel Dinu"
"RC5-20","64","128","02"," reference implementation; magic constants S table is precomputed"," Daniel Dinu"
"RC5-20","64","128","03"," reference implementation; magic constants S table is precomputed and stored in RAM"," Daniel Dinu"
"RC5-20","64","128","04"," fully unrolled reference implementation"," Daniel Dinu"
"RC5-20","64","128","05"," fully unrolled reference implementation; magic constants S table is precomputed"," Daniel Dinu"
"RC5-20","64","128","06"," fully unrolled reference implementation; magic constants S table is precomputed and stored in RAM"," Daniel Dinu"
"RC5-20","64","128","07"," reference implementation; different implementation for rotations"," Daniel Dinu"
"RC5-20","64","128","08"," reference implementation; magic constants S table is precomputed; different implementation for rotations"," Daniel Dinu"
"RC5-20","64","128","09"," reference implementation; magic constants S table is precomputed and stored in RAM; different implementation for rotations"," Daniel Dinu"
"RC5-20","64","128","10"," fully unrolled reference implementation; different implementation for rotations"," Daniel Dinu"
"RC5-20","64","128","11"," fully unrolled reference implementation; magic constants S table is precomputed; different implementation for rotations"," Daniel Dinu"
"RC5-20","64","128","12"," fully unrolled reference implementation; magic constants S table is precomputed and stored in RAM; different implementation for rotations"," Daniel Dinu"
"RECTANGLE","64","128","01"," Reference C implementation with key schedule"," Adnan Baysal"
"RECTANGLE","64","128","02"," Assembler implementation for AVR, MSP and ARM."," Bao Zhenzhen, Luo Peng, Zhang Wentao"
"RECTANGLE","64","128","03"," Optimized C implementation is used on ARM."," Bao Zhenzhen, Luo Peng, Zhang Wentao"
"RECTANGLE","64","128","04"," Optimized C implementation for all platformss."," Bao Zhenzhen, Luo Peng, Zhang Wentao"
"RECTANGLE","64","128","05"," Optimization for RAM on AVR."," Bao Zhenzhen, Luo Peng, Zhang Wentao"
"RECTANGLE","64","128","06"," Optimized the assembler implementation."," Bao Zhenzhen, Luo Peng, Zhang Wentao"
"RECTANGLE","64","128","07"," Optimize the assembler implementation a little"," Luo Peng"
"RECTANGLE","64","128","08"," unroll five rounds for MSP and ARM"," Luo Peng"
"RECTANGLE","64","128","09"," fully unrolled for MSP and ARM"," Luo Peng"
"RECTANGLE","64","80","01"," Reference C implementation with key schedule"," Adnan Baysal"
"RECTANGLE","64","80","02"," Assembler implementation for AVR, MSP and ARM."," Bao Zhenzhen, Luo Peng, Zhang Wentao"
"RECTANGLE","64","80","03"," Optimized C implementation is used on ARM."," Bao Zhenzhen, Luo Peng, Zhang Wentao"
"RECTANGLE","64","80","04"," Optimized C implementation for all platforms."," Bao Zhenzhen, Luo Peng, Zhang Wentao"
"RECTANGLE","64","80","05"," Optimization for RAM on AVR."," Bao Zhenzhen, Luo Peng, Zhang Wentao"
"RECTANGLE","64","80","06"," Optimized the assembler implementation."," Bao Zhenzhen, Luo Peng, Zhang Wentao"
"RECTANGLE","64","80","07"," Optimize the assembler implementation a little"," Luo Peng"
"RECTANGLE","64","80","08"," unroll five rounds for MSP and ARM"," Luo Peng"
"RECTANGLE","64","80","09"," fully unrolled for MSP and ARM"," Luo Peng"
"RoadRunneR","64","128","01"," Reference C implementation, no key schedule"," Adnan Baysal"
"RoadRunneR","64","128","02"," Reference C implementation with key schedule"," Adnan Baysal"
"RoadRunneR","64","128","03"," Implementation with no extra function call, no key schedule"," Adnan Baysal"
"RoadRunneR","64","128","04"," Implementation with no extra function call, using key schedule"," Adnan Baysal"
"RoadRunneR","64","128","05"," Implementation with single common function call in Encrypt/Decrypt, no key schedule"," Adnan Baysal"
"RoadRunneR","64","128","06"," Implementation with single common function call in Encrypt/Decrypt, using key schedule"," Adnan Baysal"
"RoadRunneR","64","80","01"," Reference C implementation, no key schedule"," Adnan Baysal"
"RoadRunneR","64","80","02"," Reference C implementation with key schedule"," Adnan Baysal"
"Robin","128","128","01"," reference implementation"," Johann Großschädl"
"Robin","128","128","02"," reference implementation; store L-Boxes in RAM"," Johann Großschädl"
"RobinStar","128","128","01"," reference implementation"," Johann Großschädl, Daniel Dinu"
"RobinStar","128","128","02"," reference implementation; store L-Boxes in RAM"," Johann Großschädl, Daniel Dinu"
"RobinStar","128","128","03"," reference implementation; improve constant generation"," Johann Großschädl, Daniel Dinu"
"RobinStar","128","128","04"," reference implementation; store L-Boxes in RAM; improve constant generation"," Johann Großschädl, Daniel Dinu"
"Simon","64","128","01"," Single round per loop iteration"," Bryan Weeks, Jason Smith, Yann Le Corre"
"Simon","64","128","02"," Two rounds per loop iteration"," Bryan Weeks, Jason Smith, Yann Le Corre"
"Simon","64","128","03"," Four rounds per loop iteration"," Bryan Weeks, Jason Smith, Yann Le Corre"
"Simon","64","128","04"," Single round per loop iteration in assembly for MSP and AVR"," Jason Smith, Bryan Weeks, Yann Le Corre"
"Simon","64","128","05"," Two rounds per loop iteration in assembly for MSP and AVR"," Jason Smith, Bryan Weeks, Yann Le Corre"
"Simon","64","128","06"," Four rounds per loop iteration in assembly for MSP and AVR"," Jason Smith, Bryan Weeks, Yann Le Corre"
"Simon","64","96","01"," optimized reference implementation"," Yann Le Corre"
"Simon","64","96","02"," optimized reference implementation, use only rotations by 1 and 8"," Yann Le Corre"
"Simon","64","96","03"," optimized reference implementation, use only rotations by 1 and 8. No unrolling"," Yann Le Corre"
"Simon","64","96","04"," Single round per loop iteration"," Bryan Weeks, Jason Smith, Yann Le Corre"
"Simon","64","96","05"," Two rounds per loop iteration"," Bryan Weeks, Jason Smith, Yann Le Corre"
"Simon","64","96","06"," Six rounds per loop iteration"," Jason Smith, Bryan Weeks, Yann Le Corre"
"Simon","64","96","07"," Single round per loop iteration in assembly for MSP and AVR"," Jason Smith, Bryan Weeks, Yann Le Corre"
"Simon","64","96","08"," Two rounds per loop iteration in assembly for MSP and AVR"," Jason Smith, Bryan Weeks, Yann Le Corre"
"Simon","64","96","09"," Six rounds unrolled in assembly for MSP and AVR"," Jason Smith, Bryan Weeks, Yann Le Corre"
"SKINNY","128","128","01"," Skinny 128-128",""
"SKINNY","128","128","02"," Cipher implementation example"," "
"SKINNY","128","128","03"," Cipher implementation example"," "
"SKINNY","64","128","01"," Skinny 64-128",""
"SKINNY","64","128","02"," Cipher implementation example"," "
"SPARX","128","128","01"," SPARX reference implementation"," Daniel Dinu"
"SPARX","128","128","02"," SPARX reference implementation; use optimized rotations"," Daniel Dinu"
"SPARX","128","128","03"," SPARX reference implementation; use optimized rotations; ASM with macros"," Daniel Dinu"
"SPARX","128","128","04"," SPARX reference implementation; use optimized rotations; ASM with macros; 2 rounds at a time"," Daniel Dinu"
"SPARX","128","128","05"," SPARX reference implementation; use optimized rotations; ASM with macros; 2 rounds at a time; fully unrolled (AVR and MSP; ARM - offset out of range error) (except for KS)"," Daniel Dinu"
"SPARX","128","128","06"," SPARX reference implementation; use optimized rotations; ASM with macros; roll A in A_3;"," Daniel Dinu"
"SPARX","128","128","07"," SPARX reference implementation; use optimized rotations; ASM with macros; lighter L for AVR"," Daniel Dinu"
"SPARX","128","128","08"," SPARX reference implementation; use optimized rotations; ASM with macros; 2 rounds at a time; lighter L for AVR"," Daniel Dinu"
"SPARX","128","128","09"," SPARX reference implementation; use optimized rotations; ASM with macros; 2 rounds at a time; fully unrolled (AVR and MSP; ARM - offset out of range error) (except for KS); lighter L for AVR"," Daniel Dinu"
"SPARX","128","128","10"," SPARX reference implementation; use optimized rotations; ASM with macros; roll A in A_3; lighter L for AVR"," Daniel Dinu"
"SPARX","128","128","11"," SPARX reference implementation; use optimized rotations; ASM with macros; lighter L for AVR; partially unrolled KS"," Daniel Dinu"
"SPARX","128","128","12"," SPARX reference implementation; use optimized rotations; ASM with macros; 2 rounds at a time; lighter L for AVR; partially unrolled KS"," Daniel Dinu"
"SPARX","128","128","13"," SPARX reference implementation; use optimized rotations; ASM with macros; 2 rounds at a time; fully unrolled (AVR and MSP; ARM - offset out of range error) (except for KS); lighter L for AVR; partially unrolled KS"," Daniel Dinu"
"SPARX","128","128","14"," SPARX reference implementation; use optimized rotations; ASM with macros; roll A in A_3; lighter L for AVR; partially unrolled KS"," Daniel Dinu"
"SPARX","128","128","15"," SPARX reference implementation; use optimized rotations; ASM with macros; 2 rounds at a time; lighter L for AVR; partially unrolled KS; roll A in A_3"," Daniel Dinu"
"SPARX","128","128","16"," SPARX reference implementation; use optimized rotations; ASM with macros; lighter L for AVR; use 16-bit branches on ARM"," Daniel Dinu"
"SPARX","128","128","17"," SPARX reference implementation; use optimized rotations; ASM with macros; 2 rounds at a time; lighter L for AVR; use 16-bit branches on ARM"," Daniel Dinu"
"SPARX","128","128","18"," SPARX reference implementation; use optimized rotations; ASM with macros; roll A in A_3; lighter L for AVR; use 16-bit branches on ARM"," Daniel Dinu"
"SPARX","128","128","19"," SPARX reference implementation; use optimized rotations; ASM with macros; 2 rounds at a time; roll A in A_3; lighter L for AVR; use 16-bit branches on ARM"," Daniel Dinu"
"SPARX","128","128","20"," SPARX reference implementation; use optimized rotations; ASM with macros; lighter L for AVR; use 16-bit branches on ARM; try to optimize ADD_ROUND_KEY (better) and ENC_ADD_WHITENING_KEY (the same)"," Daniel Dinu"
"SPARX","128","128","21"," SPARX reference implementation; use optimized rotations; ASM with macros; 2 rounds at a time; lighter L for AVR; use 16-bit branches on ARM; try to optimize ADD_ROUND_KEY (better) and ENC_ADD_WHITENING_KEY (the same)"," Daniel Dinu"
"SPARX","128","128","22"," SPARX reference implementation; use optimized rotations; ASM with macros; roll A in A_3; lighter L for AVR; use 16-bit branches on ARM; try to optimize ADD_ROUND_KEY (better) and ENC_ADD_WHITENING_KEY (the same)"," Daniel Dinu"
"SPARX","128","128","23"," SPARX reference implementation; use optimized rotations; ASM with macros; 2 rounds at a time; roll A in A_3; lighter L for AVR; use 16-bit branches on ARM; try to optimize ADD_ROUND_KEY (better) and ENC_ADD_WHITENING_KEY (the same)"," Daniel Dinu"
"SPARX","128","128","24"," SPARX reference implementation; use optimized rotations; ASM with macros; lighter L for AVR; use 16-bit branches on ARM; try to optimize ADD_ROUND_KEY (better) and ENC_ADD_WHITENING_KEY (the same)"," Daniel Dinu"
"SPARX","64","128","01"," SPARX reference implementation"," Daniel Dinu"
"SPARX","64","128","02"," SPARX reference implementation; use optimized rotations"," Daniel Dinu"
"SPARX","64","128","03"," SPARX reference implementation; use optimized rotations; roll Speckey in round function"," Daniel Dinu"
"SPARX","64","128","04"," SPARX reference implementation; use optimized rotations; unroll 2 rounds per loop"," Daniel Dinu"
"SPARX","64","128","05"," SPARX reference implementation; use optimized rotations; roll Speckey in round function; unroll 2 rounds per loop"," Daniel Dinu"
"SPARX","64","128","06"," SPARX reference implementation; use optimized rotations; unroll all loops"," Daniel Dinu"
"SPARX","64","128","07"," SPARX reference implementation; use optimized rotations; unroll all loops; process 2 rounds at a time"," Daniel Dinu"
"SPARX","64","128","08"," SPARX reference implementation; use optimized rotations; use only 16-bit operations"," Daniel Dinu"
"SPARX","64","128","09"," SPARX reference implementation; use optimized rotations; use only 16-bit operations with just 1 pointer"," Daniel Dinu"
"SPARX","64","128","10"," SPARX reference implementation; use optimized rotations; use only 16-bit operations with just 1 pointer; use a register for key schedule"," Daniel Dinu"
"SPARX","64","128","11"," SPARX reference implementation; use optimized rotations; ASM"," Daniel Dinu"
"SPARX","64","128","12"," SPARX reference implementation; use optimized rotations; ASM with macros"," Daniel Dinu"
"SPARX","64","128","13"," SPARX reference implementation; use optimized rotations; ASM with macros; 2 rounds at a time"," Daniel Dinu"
"SPARX","64","128","14"," SPARX reference implementation; use optimized rotations; ASM with macros; fully unrolled (except for KS)"," Daniel Dinu"
"SPARX","64","128","15"," SPARX reference implementation; use optimized rotations; ASM with macros; roll A in A_3"," Daniel Dinu"
"SPARX","64","128","16"," SPARX reference implementation; use optimized rotations; ASM with macros; limit the number of registers used"," Daniel Dinu"
"SPARX","64","128","17"," SPARX reference implementation; use optimized rotations; ASM with macros; 2 rounds at a time; limit the number of registers used"," Daniel Dinu"
"SPARX","64","128","18"," SPARX reference implementation; use optimized rotations; ASM with macros; fully unrolled (except for KS); limit the number of registers used"," Daniel Dinu"
"SPARX","64","128","19"," SPARX reference implementation; use optimized rotations; ASM with macros; roll A in A_3; limit the number of registers used"," Daniel Dinu"
"SPARX","64","128","20"," SPARX reference implementation; use optimized rotations; ASM with macros; limit the number of registers used; partially unrolled KS"," Daniel Dinu"
"SPARX","64","128","21"," SPARX reference implementation; use optimized rotations; ASM with macros; 2 rounds at a time; limit the number of registers used; partially unrolled KS"," Daniel Dinu"
"SPARX","64","128","22"," SPARX reference implementation; use optimized rotations; ASM with macros; fully unrolled (except for KS); limit the number of registers used; partially unrolled KS"," Daniel Dinu"
"SPARX","64","128","23"," SPARX reference implementation; use optimized rotations; ASM with macros; roll A in A_3; limit the number of registers used; partially unrolled KS"," Daniel Dinu"
"SPARX","64","128","24"," SPARX reference implementation; use optimized rotations; ASM with macros; 2 rounds at a time; roll A in A_3; limit the number of registers used"," Daniel Dinu"
"SPARX","64","128","25"," SPARX reference implementation; use optimized rotations; ASM with macros; limit the number of registers used; use 16-bit branches on ARM"," Daniel Dinu"
"SPARX","64","128","26"," SPARX reference implementation; use optimized rotations; ASM with macros; 2 rounds at a time; limit the number of registers used; use 16-bit branches on ARM"," Daniel Dinu"
"SPARX","64","128","27"," SPARX reference implementation; use optimized rotations; ASM with macros; 2 rounds at a time; fully unrolled (except for KS); limit the number of registers used; use 16-bit branches on ARM"," Daniel Dinu"
"SPARX","64","128","28"," SPARX reference implementation; use optimized rotations; ASM with macros; roll A in A_3; limit the number of registers used; use 16-bit branches on ARM"," Daniel Dinu"
"SPARX","64","128","29"," SPARX reference implementation; use optimized rotations; ASM with macros; 2 rounds at a time; roll A in A_3; limit the number of registers used; use 16-bit branches on ARM"," Daniel Dinu"
"SPARX","64","128","30"," SPARX reference implementation; use optimized rotations; ASM with macros; limit the number of registers used; use 16-bit branches on ARM; try to optimize ADD_ROUND_KEY (better) and ENC_ADD_WHITENING_KEY (the same)"," Daniel Dinu"
"SPARX","64","128","31"," SPARX reference implementation; use optimized rotations; ASM with macros; 2 rounds at a time; limit the number of registers used; use 16-bit branches on ARM; try to optimize ADD_ROUND_KEY (better) and ENC_ADD_WHITENING_KEY (the same)"," Daniel Dinu"
"SPARX","64","128","32"," SPARX reference implementation; use optimized rotations; ASM with macros; 2 rounds at a time; fully unrolled (except for KS); limit the number of registers used; use 16-bit branches on ARM; try to optimize ADD_ROUND_KEY (better) and ENC_ADD_WHITENING_KEY (the same)"," Daniel Dinu"
"SPARX","64","128","33"," SPARX reference implementation; use optimized rotations; ASM with macros; roll A in A_3; limit the number of registers used; use 16-bit branches on ARM; try to optimize ADD_ROUND_KEY (better) and ENC_ADD_WHITENING_KEY (the same)"," Daniel Dinu"
"SPARX","64","128","34"," SPARX reference implementation; use optimized rotations; ASM with macros; 2 rounds at a time; roll A in A_3; limit the number of registers used; use 16-bit branches on ARM; try to optimize ADD_ROUND_KEY (better) and ENC_ADD_WHITENING_KEY (the same)"," Daniel Dinu"
"SPARX","64","128","35"," SPARX reference implementation; use optimized rotations; ASM with macros; 2 rounds at a time; roll A in A_3; limit the number of registers used; use 16-bit branches on ARM; try to optimize ADD_ROUND_KEY (better) and ENC_ADD_WHITENING_KEY (the same) and EKS_STORE_ROUND_KEYS (worse = slower)"," Daniel Dinu"
"Speck","64","128","01"," Optimized C code"," Jason Smith, Yann Le Corre"
"Speck","64","128","02"," Single round per loop iteration in assembly for AVR and MSP"," Jason Smith, Yann Le Corre"
"Speck","64","128","03"," Unroll three rounds per loop iteration for higher performance at reasonable code size"," Jason Smith, Yann Le Corre"
"Speck","64","128","04"," Three rounds per loop iteration in assembly for AVR and MSP"," Jason Smith, Yann Le Corre"
"Speck","64","128","05"," Unroll nine rounds per loop iteration for highest performance"," Jason Smith, Yann Le Corre"
"Speck","64","128","06"," Nine rounds per loop iteration in assembly for AVR and MSP"," Jason Smith, Yann Le Corre"
"Speck","64","96","01"," optimized reference implementation"," Yann Le Corre"
"Speck","64","96","02"," optimized reference implementation. Use only rotations by 1 on 8"," Yann Le Corre"
"Speck","64","96","03"," Optimized C code"," Jason Smith, Yann Le Corre"
"Speck","64","96","04"," Single round per loop iteration in assembly for AVR and MSP"," Jason Smith, Yann Le Corre"
"Speck","64","96","05"," Unroll two rounds per loop iteration for high performance at reasonable code size."," Jason Smith, Yann Le Corre"
"Speck","64","96","06"," Unroll two rounds per loop iteration for high performance at reasonable code size."," Jason Smith, Yann Le Corre"
"Speck","64","96","07"," Unroll three rounds per loop iteration for encrypt and two for decrypt for high performance."," Jason Smith, Yann Le Corre"
"Speck","64","96","08"," Unroll three rounds per loop iteration for encrypt and two for decrypt for high performance. Assembly implementation for AVR and MSP."," Jason Smith, Yann Le Corre"
"Speck","64","96","09"," Unroll 13 rounds per loop iteration for high performance."," Jason Smith, Yann Le Corre"
"Speck","64","96","10"," Unroll many rounds for highest performance"," Jason Smith, Yann Le Corre"
"TWINE","64","80","01"," Speed-optimized implementation of Twine with 80-bit key"," Dmitry Khovratovich"
"TWINE","64","80","02"," Size-optimized implementation of Twine with 80-bit key"," Dmitry Khovratovich"
"TWINE","64","80","03"," Speed-optimized implementation of Twine with 80-bit key; store all constants in RAM"," Dmitry Khovratovich"
"TWINE","64","80","04"," Size-optimized implementation of Twine with 80-bit key; store all constants in RAM"," Dmitry Khovratovich"
